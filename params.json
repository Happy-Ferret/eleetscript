{"name":"Cuby","tagline":"A ruby hosted scripting language, designed to add a scripting component on top or ruby applications.","body":"# What is Cuby?\r\n\r\nCuby is a no-error scripting language built to run on top of Ruby applications for additional or easy-to-change pieces of functionality. Cuby's core libraries are meant to be few in number to provide bare essentials and not (by default) allow File or Process access/management making it easy to secure a Cuby runtime (use it's default settings!). The original purpose of Cuby was to act as scripting language for a Ruby MUD server I was building and I wanted something quick to throw in to the application that I could easily run code on and not worry about crashing the server or doing harm to the system itself. \r\n\r\n## Goals\r\n\r\nThe core goals behind Cuby are to provide a single (or minimal) way to perform certain tasks and have clean syntax that is readable by itself.\r\n\r\nCuby was partly inspired by Ruby where you can define blocks in two different ways:\r\n\r\n```ruby\r\nlist.map do |item|\r\n  item\r\nend\r\n\r\nlist.map { |item| item }\r\n```\r\n\r\nAnd those are blocks, methods look different:\r\n\r\n```ruby\r\ndef some_method\r\n  nil\r\nend\r\n```\r\n\r\nWhile I have nothing against this approach and I love working in Ruby - I wanted something that was simple and easy to get into. Once a newcomer learned how to do something I didn't want them to encounter new or strange ways to do the same thing in the future, perhaps reading another persons work.\r\n\r\nIn Cuby, methods and blocks all use Ruby's `do..end` syntax, I chose this because a function _does_ something, so when you write one, why not tell it _what to do_?\r\n\r\n```cuby\r\nsome_method do\r\n  nil\r\nend\r\n\r\nitems.map() do |item|\r\n  item\r\nend\r\n```\r\n\r\n## No Errors?\r\n\r\nI realize the downsides that can accompany an errorless system, for example harder to find out why exactly you code doesn't work. The reason I went this path is to open up scripting in the MUD to non-professional developers and not have to worry that their mistakes would break whatever objects they were scripting. The script would fail gracefully (and silently) and standard behavior for the object would follow instead of the coded behavior. Cuby scripts aren't meant to be chock full of logic either so with minimal actions going on in a script and a system that needs to maintain operational status I chose to not deliver any errors from the interpreter and have things silently fail.\r\n\r\nSome examples of silently failing:\r\n\r\n```cuby\r\nclass Dummy end\r\nDummy.create # While all object have a \"new\" method, we did not define a \"create\" class method here\r\n\r\n# Calling methods that don't exist invoke Object#__nil_method which simply returns nil.\r\n# Given the open nature of Cuby, if you needed you could override __nil_method to do what \r\n# you needed per class or globally although changing core functionality is not suggested\r\n\r\nConstant = 10\r\n\r\nConstant = 20 # Normally this would prompt an error, can't reassign a Constant. It doesn't\r\n\r\n# It just simply ignores the reassignment.\r\nprintln(Constant) # => 10 \r\n\r\nsome_var_that_isnt_defined # just nil\r\n```\r\n\r\nCuby is built to avoid crashing on these situations to keep the execution of the script smooth.\r\n\r\n# Features\r\n\r\nWhat does Cuby have to offer as a scripting language? Honestly? Nothing groundbreaking or new. I've used quite a bit of languages and pulled features that I felt were easier and more readable from several languages. The name \"Cuby\" is actually a mashup (of sorts) of CoffeeScript and Ruby as those were my two base inspirations.\r\n\r\n## Literals, Variables and the basics\r\n\r\n### Literals\r\n\r\n```cuby\r\n# Anything starting with a \"#\" is a comment to the next newline (\\n) and ignored by the Lexer\r\n\r\n\"Strings\" # Strings can only be made with double quotes\r\n# Numbers all derive from \"Number\" at the base, but Cuby knows the difference between Integers and Floats\r\n10 # Is an Integer\r\n1.0 # Is a Float\r\n\r\n# Numbers support _ as a seperator\r\n100_000 # => 100000\r\n100_000.000_001 # => 100000.000001\r\n\r\n# Boolean values are where Cuby deviates from it's \"one way only\" methodology, true and\r\n# false have three separate (but equal) representations.\r\n# True - all of these evaluate to true\r\ntrue\r\non\r\nyes\r\n\r\n# False - all of these evaluate to false\r\nfalse\r\noff\r\nno\r\n\r\n# The reason for this is readability, sometimes 'true' doesn't read the true intention\r\n# for example\r\nmy_flag = true # easy to understand and recognize, but\r\nmy_flag = on # better represents the programmers intent, to turn the flag on\r\n\r\n# Lists, Cuby's array/hash class, can be a \"literal\"\r\n[1, 2, 3] # With just array values\r\n\r\n[1, 2, \"msg\" => \"Hello!\"] # With array and hash values\r\n\r\n# The 'key => value' syntax in Cuby is really just sugar for creating a Pair, Consider:\r\n[1, 2, \"msg\" => \"Hello\"]\r\n\r\n# Is functionally the same as \r\nList.new(1, 2, Pair.new(\"msg\", \"Hello\"))\r\n\r\n# This opens this pair functionality to user defined classes and variable assignments\r\n```\r\n\r\n### Varbiable Types\r\n\r\n```cuby\r\n# There are several different kinds of variables in Cuby, all have specific scopes.\r\n\r\nA_CONSTANT # starts with a capital letter (a la Ruby) and can contain underscores and numbers\r\nAlsoAConstant\r\n# Constants can only be assigned literal values, not evaluated expressions\r\n\r\n$global # Global values start with a $ and belong to the highest level \"Namespace\"\r\n\r\n@instance # Instance variables begin with a single @ and belong to an instance of a class, classes do not share instances\r\n\r\n@@class # Belongs to a class, and accessible by all instances of the class.\r\n\r\nlocal # Simple local names, these fallback to methods if no local is defined.\r\n\r\n# Variable names can end with ? or ! characters, these are more generally used for \r\n# special method meanings where ? represents the method will return true or false\r\n# and that methods with ! will modify or change the object you call the method on.\r\n# However these can be used with variables too\r\n\r\nmy_question?\r\nserious_bizness!\r\n```\r\n\r\n### Variable Assignment and Usage\r\n\r\n```cuby\r\n# Variable assignment is a simple '='\r\nmy_var = 10\r\n\r\n$this_global = \"Hello\"\r\n\r\nA_CONSTANT = \"NEVER CHANGING\"\r\n```\r\n\r\n### Using and Defining Methods\r\n\r\n```cuby\r\n# Methods are action blocks that perform tasks when invoked.\r\nmy_action do\r\n  println(\"It Worked!\")\r\nend\r\n\r\n# Here I define 'my_action' as a method that prints (using println, another method) \"It Worked!\"\r\n# Methods are invoked by 'calling' them with parenthesis\r\nmy_action() # => \"It Worked!\"\r\n\r\n# Methods that don't take parameters can be called without parenthesis\r\nmy_action # => \"It Worked!\"\r\n\r\n# But doing this has a caveat, if a local is defined with the same name, the local will\r\n# be accessed instead. Using '()' will always ensure the method is called\r\nmy_action = 10\r\nmy_action # => 10\r\nmy_action() # => \"It Worked!\"\r\n\r\n# Methods that don't take parameters can be useful, but oftentimes you'll need to\r\n# pass different data to them, this is done with a parameter list in pipes (|)\r\nadd do |a, b|\r\n  a + b\r\nend\r\n\r\n# Here is an add function that takes two parameters, a and b. It's important to note,\r\n# the result of the last expression is always returned from a method unless an \r\n# explicit return in encountered. Therefore I could use this method to add numbers\r\n\r\nten = add(6, 4)\r\nprintln(ten) # => 10\r\n\r\n# You don't have to specify parameters to accept arguments to a function, every \r\n# method has a 'magic' arguments local that is a List of all passed arguments.\r\nadd2 do\r\n  arguments[0] + arguments[1]\r\nend\r\n\r\n# This add does the same thing, but doesn't specify parameter names\r\nten = add2(6, 4)\r\nprintln(ten) # => 10\r\n\r\n# Calling methods that don't exist is nothing to fret about, there is a special method\r\n# used in these cases.\r\nprintln(i_dont_exist()) # => \"nil\"\r\n```\r\n\r\n### Classes, Class Methods, Methods and Instances\r\n\r\nCuby is Object Oriented, and everything is an Object (everything). In order to suit the needs of the script you may be writing Cuby provides syntax for defining your own classes as well as modifying existing classes.\r\n\r\n```cuby\r\n# Lets build a Greeter\r\nclass Greeter end\r\n\r\n# This is a simple empty class defined in Cuby, all classes extend Object (unless a\r\n# different parent is specified) so even though we didn't define anything special\r\n# about Greeter we can still call methods on it\r\ng = Greeter.new\r\ng.class_name # => \"Greeter\"\r\ng.to_string # => \"Greeter\"\r\ng.inspect # => \"Greeter\"\r\ng.clone # => A new instance of Greeter\r\ng.kind_of?(\"Greeter\") # => true\r\ng.kind_of?(\"Object\") # => true\r\ng.kind_of?(\"Number\") # => false\r\n\r\n# NOTE: While you can change the behavior of the 'new' function it's not recommended\r\n# as doing so will prevent the class from being able to spawn instances of itself,\r\n# if that is not necessary then feel free to do so.\r\n\r\n# This Greeter class is kind of useless, lets reopen and add features to it\r\nclass Greeter\r\n  init do |greeting|\r\n    @greeting = greeting\r\n  end\r\n\r\n  greeting do\r\n    @greeting\r\n  end\r\n\r\n  greeting= do |greeting|\r\n    @greeting\r\n  end\r\n\r\n  greet do |name|\r\n    println(\"%@greeting, %name\")\r\n  end\r\nend\r\n\r\n# We've reopened the Greeter class and defined 4 new methods, 'init', 'greeting', \r\n# 'greeting=', and 'greet'. There are couple of things to mention for this example:\r\n# The 'init' function of a class is called when you create a new instance of that class,\r\n# and any arguments you give 'new' will be passed to 'init'. We can now do:\r\ng = Greeter.new(\"Hello\") # to create a Greeter with a greeting.\r\n\r\n# The 'init' function sets the value of the instance variable @greeting\r\n\r\n# The next two function 'greeting' and 'greeting=' are getters and setters for the\r\n# greeting variable. In Cuby best practice getters should be named the same as the value\r\n# they are fetching and setters should be named the same way followed by an '='\r\ng.greeting # => returned \"Hello\"\r\n\r\n# The setter can be used just like standard method calls\r\ng.greeting=(\"Hola\")\r\n\r\n# but also with a bit of sugar\r\ng.greeting = \"Hello\" # This is converted into g.greeting=(\"Hello\") by the Parser\r\n\r\n# Finally we have the 'greet' method which prints \"%@greeting, %name\", this is special\r\n# string syntax that interpolates the values of the variables named after the %, the\r\n# result of calling\r\ng.greet(\"World\")\r\n\r\n# is \"Hello, World\"\r\n\r\n# NOTE: Interpolation ONLY works on variables, not expressions or literals.\r\n\r\n# The Greeter example is \"complete\", but can be greatly simplified. There is a special\r\n# way in Cuby for assigning parameters to instance or class variables.\r\n\r\nclass Greeter\r\n  init do |@greeting| end\r\n\r\n  greeting= do |@greeting| end\r\nend\r\n\r\n# Here the parameter is now named @greeting which will automatically assign this \r\n# instance variable to the value passed as the first parameter.\r\n\r\n# Getters and Setters are also really common so there is a property keyword that defines\r\n# them for you.\r\n\r\nclass Greeter\r\n  property greeting\r\nend\r\n\r\n# This property keyword takes all names listed after it and creates a getter and setter\r\n# like the ones defined earlier. These getters and setters will modify an instance \r\n# variable with the same name, in this case @greeting\r\n\r\n# This makes the bulk of class definitions logic, and not mundane simple tasks. Take the\r\n# Pair class from Cuby's core\r\nclass Pair\r\n  property key value\r\n  init do |@key, @value| end\r\nend\r\n\r\n# Simple, and functional. Notice how the values listed after the property keyword are \r\n# not separated by commas, just spaces. They also must be on the same line.\r\n\r\n# Class variables belong to classes, not instances of the class, these are useful when\r\n# all instances share data, like an instantiation count\r\nclass Counter\r\n  @@count = 0\r\n  init do\r\n    @@count += 1\r\n  end\r\nend\r\n\r\n# Class methods are methods that belong to a class and not an instance and they share \r\n# similar syntax.\r\nclass Counter\r\n  @@count do\r\n    @@count\r\n  end\r\nend\r\n\r\n# Now we have a class method 'count' we can use to return the value of class variable\r\n# '@@count'\r\nprintln(Counter.count) # => 2\r\n\r\n# To end this discussion on classes, everything in Cuby is an object, and all actions\r\n# are methods.\r\n1 + 10 # == 1.+(10)\r\ntrue and false # == true.and(false)\r\nnot false # == false.not\r\n\r\n# Assignment operations are just sugar for assigning the result of an operation\r\ni += 10 # == i = i.+(10)\r\n\r\n# NOTE: Assignments are the only thing that are not function calls, but assignment \r\n# operations use their respective operator function before performing the assignment.\r\n```\r\n\r\n### Operators\r\n\r\n# Listed in order of precedence\r\n\r\n<table>\r\n  <thead>\r\n    <tr>\r\n      <td><strong>Precedence<strong></td>\r\n      <td><strong>Operator<strong></td>\r\n      <td><strong>Purpose</strong></td>\r\n      <td><strong>Example</strong></td>\r\n      <td><strong>Can be Overriden?</strong></td>\r\n    </tr>\r\n  </thead>\r\n  <tbody>\r\n    <tr>\r\n      <td>1</td>\r\n      <td><code>.</code></td>\r\n      <td>Call a method on the object</td>\r\n      <td><code>a.method_name</code></td>\r\n      <td>No</td>\r\n    </tr>\r\n    <tr>\r\n      <td>2</td>\r\n      <td><code>**</code></td>\r\n      <td>Generally used for raising numbers to a certain power</td>\r\n      <td><code>2 ** 3 => 8</code></td>\r\n      <td>Yes</td>\r\n    </tr>\r\n\t<tr>\r\n      <td>3</td>\r\n      <td><code>*</code></td>\r\n      <td>Used to multiply numbers</td>\r\n      <td><code>2 * 3 => 6</code></td>\r\n      <td>Yes</td>\r\n    </tr>\r\n\t<tr>\r\n      <td>3</td>\r\n      <td><code>/</code></td>\r\n      <td>Used to divide numbers</td>\r\n      <td><code>6 / 2 => 3</code></td>\r\n      <td>Yes</td>\r\n    </tr>\r\n\t<tr>\r\n      <td>3</td>\r\n      <td><code>%</code></td>\r\n      <td>Used to modularly divide numbers</td>\r\n      <td><code>7 % 2 => 1</code></td>\r\n      <td>Yes</td>\r\n    </tr>\r\n\t<tr>\r\n      <td>4</td>\r\n      <td><code>+</code></td>\r\n      <td>Add two numbers together</td>\r\n      <td><code>2 + 3 => 5</code></td>\r\n      <td>Yes</td>\r\n    </tr>\r\n\t<tr>\r\n      <td>4</td>\r\n      <td><code>-</code></td>\r\n      <td>Subtract two numbers</td>\r\n      <td><code>10 - 5 => 5</code></td>\r\n      <td>Yes</td>\r\n    </tr>\r\n\t<tr>\r\n      <td>5</td>\r\n      <td><code>></code></td>\r\n      <td>Compare if numbers are Greater than other numbers</td>\r\n      <td><code>10 > 2 => true</code></td>\r\n      <td>Yes</td>\r\n    </tr>\r\n\t<tr>\r\n      <td>5</td>\r\n      <td><code>>=</code></td>\r\n      <td>Determine if numbers are greater than or equal to</td>\r\n      <td><code>10 > 10 => true</code></td>\r\n      <td>Yes</td>\r\n    </tr>\r\n\t<tr>\r\n      <td>5</td>\r\n      <td><code><</code></td>\r\n      <td>Determine if number is less than other</td>\r\n      <td><code>6 < 10 => true</code></td>\r\n      <td>Yes</td>\r\n    </tr>\r\n\t<tr>\r\n      <td>5</td>\r\n      <td><code><=</code></td>\r\n      <td>Determine if number is less than or equal to other number</td>\r\n      <td><code>10 <= 10 => true</code></td>\r\n      <td>Yes</td>\r\n    </tr>\r\n\t<tr>\r\n      <td>6</td>\r\n      <td><code>is</code></td>\r\n      <td>Determine if two values are equal</td>\r\n      <td><code>10 is 10 => true</code></td>\r\n      <td>Yes</td>\r\n    </tr>\r\n\t<tr>\r\n      <td>6</td>\r\n      <td><code>isnt</code></td>\r\n      <td>Determine if values are not equal</td>\r\n      <td><code>10 isnt 8 => true</code></td>\r\n      <td>Yes</td>\r\n    </tr>\r\n\t<tr>\r\n      <td>7</td>\r\n      <td><code>not</code></td>\r\n      <td>Negate boolean value</td>\r\n      <td><code>not true => false</code></td>\r\n      <td>Yes</td>\r\n    </tr>\r\n\t<tr>\r\n      <td>8</td>\r\n      <td><code>and</code></td>\r\n      <td>The result is true if both sides are true</td>\r\n      <td><code>yes and on => true</code></td>\r\n      <td>Yes</td>\r\n    </tr>\r\n\t<tr>\r\n      <td>9</td>\r\n      <td><code>or</code></td>\r\n      <td>The result is true if one side is true</td>\r\n      <td><code>no or yes => true</code></td>\r\n      <td>Yes</td>\r\n    </tr>\r\n\t<tr>\r\n      <td>10</td>\r\n      <td><code>=</code></td>\r\n      <td>Assign one value to a variable (includes all assignment operations)*</td>\r\n      <td><code>i = 10</code></td>\r\n      <td>Yes</td>\r\n    </tr>\r\n  </tbody>\r\n</table>\r\n\r\n*__Assignment Operations__: `+=` `-=` `/=` `*=` `%=` `**=`","google":"UA-43235042-1","note":"Don't delete this file! It's used internally to help with page regeneration."}